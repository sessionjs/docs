{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Session.js is JavaScript library for programmatic usage of Session messenger by OXEN. Supports server and browser environment with built-in proxy network module. Shipped with TypeScript definitions. Tested with bun:test. Written with blazingly fast Bun, a modern runtime for JavaScript and alternative to Node.js. This package cannot be used with Node.js, it uses a better runtime instead of it. It can also be used with most bundlers that support modern syntax.</p> <p>Session.js allows you to create:</p> <ul> <li>Highly optimized Session bots (hundreds of bots in a single app)</li> <li>Custom Session clients (web-based and native with JS backend)</li> <li>Automation tools for Session</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>On-demand polling \u2014 you decide when to get new messages and whether instance should poll them (and poll settings like frequency) or work just for sending</li> <li>Per-instance storage and network settings \u2014 you can attach persistant storage to instance or use in-memory storage for throwaway one-time instances</li> <li>Session.js can be used in browser, keeping private keys on client-side and doing network requests on server-side. See this in action with my full-featured Session Web client!</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<p>Jump to getting started page to start using Session.js!</p>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li> Messages</li> <li> Automatic snodes fetching</li> <li> Automatic swarms selection</li> <li> Manual snode/swarm control</li> <li> Data retrieving from swarms</li> <li> Messages polling</li> <li> Messages types<ul> <li> Regular chat message</li> <li> Text</li> <li> Attachments<ul> <li> Images</li> <li> Files</li> <li> Voice messages</li> <li> Quotes</li> <li> Web links previews</li> </ul> </li> <li> Service messages</li> <li> Sync message</li> <li> Configuration message<ul> <li>Uses legacy constructor for now</li> </ul> </li> <li> Read message (ReadReceipt)</li> <li> Typing message</li> <li> Message request response</li> <li> Screenshot / media saved (DataExtraction)</li> <li> Delete message (Unsend)</li> <li> Call message<ul> <li>Just event to display placeholder warning about unsupported feature</li> </ul> </li> </ul> </li> <li> Reactions</li> <li> Closed chats</li> <li> Open groups (SOGS)</li> <li> Expirable messages</li> <li> Calls</li> <li> Messages editing (SOGS)</li> <li> Profile editing</li> <li> Display name</li> <li> Avatar</li> <li> Syncing between devices</li> <li> ONS resolving</li> <li> Get rid of ByteBuffer and other lazy dependencies</li> </ul>"},{"location":"#license","title":"License","text":"<p>All code in Session.js (including any submodules) was written by Viktor Shchelochkov aka hloth and licensed under MIT license</p>"},{"location":"#funding","title":"Funding","text":"<p>You can donate here: hloth.dev/donate</p>"},{"location":"constants/","title":"Session client constants","text":"<p>You can use some Session client constatnts from <code>@session.js/consts</code> such as <code>CONVERSATION.MAX_VOICE_MESSAGE_DURATION</code> which should help you define limits for your client.</p> <p>Here is a full list of constants defined in that module:</p> <ul> <li>DURATION</li> <li>TTL_DEFAULT</li> <li>SWARM_POLLING_TIMEOUT</li> <li>PROTOCOLS</li> <li>CONVERSATION</li> <li>MAX_ATTACHMENT_FILESIZE_BYTES</li> <li>VALIDATION</li> <li>DEFAULT_RECENT_REACTS</li> <li>REACT_LIMIT</li> <li>MAX_USERNAME_BYTES</li> <li>FEATURE_RELEASE_TIMESTAMPS</li> </ul>"},{"location":"error-handling/","title":"Error handling","text":"<p>Session.js validates and handles a lot of errors for you, wrapping them in special different classes, so you can easily handle them on your abstract level. </p> <p>However, you absolutely should always handle errors when calling any method in Session.js. At the very least, to not crash your entire production server with unhandled thrown error.</p> <p>To handle errors correctly, install @session.js/errors:</p> <pre><code>bun add @session.js/errors\n</code></pre> <p>All errors extend from SessionJsError class, which itself extends from Error class.</p> <p>Example of handling errors:</p> <pre><code>import { Session, ready } from '@session.js/client'\nimport { \n  SessionValidationError, \n  SessionValidationErrorCode, \n  SessionJsError \n} from '@session.js/errors'\nawait ready\n\nconst session = new Session()\n\ntry {\n  session.setMnemonic('invalid mnemonic') // &lt;- throws SessionValidationError, which extends from generic Error class\n} catch(e) {\n  if(e instanceof SessionValidationError) {\n    if(e.code === SessionValidationErrorCode.InvalidMnemonic) {\n      console.error('You entered invalid mnemonic!') // &lt;- `e` will have code property with one of SessionValidationErrorCode enums\n    } else {\n      // some other SessionValidationError error\n      console.error(e.code)\n    }\n  } else if(e instanceof SessionJsError) {\n    // another error not related to validation, but related to Session.js\n    console.error(e.code)\n  } else if(e instanceof Error) {\n    // unknown error that was thrown by javascript, not Session.js\n    console.error(e.message)\n  } else {\n    // generally all errors in JavaScript extend from Error class, but\n    // it is possible to throw primitive values like `throw \"primitive string\"`\n    throw e\n  }\n}\n</code></pre>"},{"location":"events/","title":"Events","text":"<p>You can listen to a variety of events to trigger parts of your application that are responsible to react on them.</p> <pre><code>const session = new Session()\nconst onMessage = msg =&gt; { /**/ }\nsession.on('message', onMessage)\n// alias: session.addEventListener('message', onMessage)\n\nsession.off('message', onMessage)\n// alias: session.removeEventListener('message', onMessage)\n</code></pre>"},{"location":"events/#message","title":"<code>message</code>","text":"<p>New message received in DM or closed group. For advanced users: this is only emitted for DataMessage i.e. VisibleMessage i.e. message that was sent by user to the chat. This does not include service messages and other events sent by Session clients. Look at this like on a message bubble.</p> <pre><code>type PrivateMessage = {\n  type: 'private'\n}\ntype ClosedGroupMessage = {\n  type: 'group'\n  groupId: string\n}\ntype Message = (PrivateMessage | ClosedGroupMessage) &amp; {\n  id: string\n  from: string\n  text?: string\n  attachments: MessageAttachment[]\n  replyToMessage?: {\n    timestamp: number\n    author: string\n    text?: string\n    attachments?: QuotedAttachment[]\n  }\n  timestamp: number\n  getEnvelope: () =&gt; EnvelopePlus\n  getContent: () =&gt; SignalService.Content\n  getReplyToMessage: () =&gt; Message['replyToMessage']\n}\n\nsession.on('message', (message: Message) =&gt; {\n  console.log(\n    'From:', msg.from,\n    'Is from closed group:', msg.type === 'group',\n    'Group id:', msg.type === 'group' ? msg.groupId : 'Not group',\n    'Text:', msg.text ?? 'No text',\n  )\n})\n</code></pre> <p>To reply to this message, you can use getReplyToMessage() method:</p> <pre><code>session.sendMessage({ \n  to: message.from,\n  text: 'reply!',\n  replyToMessage: message.getReplyToMessage() \n})\n</code></pre>"},{"location":"events/#syncmessage","title":"<code>syncMessage</code>","text":"<p>This event is intended to let your instance know that the message was sent from your Session ID to another Session ID. This is useful when a person uses many devices and this event lets your client know that they sent message from another device.</p> <p>This event will be triggered on the instance that used sendMessage</p> <pre><code>export type SyncMessage = Omit&lt;Message, 'from'&gt; &amp; { to: string }\n// interface is the same as above, but instead of `from` field we have `to` \n// which indicates Session ID that the user sent message to\n\nsession.on('syncMessage', (message: SyncMessage) =&gt; {\n  console.log(\n    'To:', msg.to,\n    'Is to closed group:', msg.type === 'group',\n    'Group id:', msg.type === 'group' ? msg.groupId : 'Not group',\n    'Text:', msg.text ?? 'No text',\n  )\n})\n</code></pre>"},{"location":"events/#syncdisplayname","title":"<code>syncDisplayName</code>","text":"<p>This event will be triggered on the instance that used setDisplayName</p> <p>One of instances changed this Session ID assosiated profile display name.</p> <pre><code>session.on('syncDisplayName', newDisplayName =&gt; {\n  console.log('My new display name is', newDisplayName)\n})\n</code></pre>"},{"location":"events/#syncavatar","title":"<code>syncAvatar</code>","text":"<p>This event will be triggered on the instance that used setAvatar</p> <p>One of instances changed this Session ID assosiated profile display name.</p> <pre><code>session.on('syncDisplayName', newAvatar =&gt; {\n  const newAvatarFile = await session.getFile(newAvatar) // =&gt; File\n  console.log('My new avatar is', newAvatarFile)\n})\n</code></pre>"},{"location":"events/#messagedeleted","title":"<code>messageDeleted</code>","text":"<p>This event will be triggered on the instance that used deleteMessage</p> <p>Message has been deleted.</p> <pre><code>type MessageDeleted = {\n  /** Timestamp of deleted message sent in that message constructor. Lookup message by timestamp in saved messages */\n  timestamp: number,\n  /** Sender of message that deleted it */\n  from: string\n}\n\nsession.on('messageDeleted', (messageDeleted: MessageDeleted) =&gt; {\n  console.log(\n    'Message with timestamp', messageDeleted.timestamp,\n    'sent by', messageDeleted.from,\n    'was deleted'\n  )\n})\n</code></pre>"},{"location":"events/#messageread","title":"<code>messageRead</code>","text":"<p>Message has been read.</p> <pre><code>type MessageReadEvent = {\n  /** Timestamp of read message sent in this message constructor. Lookup message by timestamp among locally saved messages */\n  timestamp: number,\n  /** Session ID of conversation where message was read */\n  conversation: string\n}\n\nsession.on('messageRead', (messageRead: MessageReadEvent) =&gt; {\n  console.log(\n    'Message with timestamp', messageRead.timestamp,\n    'was read in conversation', messageRead.conversation\n  )\n})\n</code></pre>"},{"location":"events/#messagetypingindicator","title":"<code>messageTypingIndicator</code>","text":"<p>Typing indicator appeared or disappeared.</p> <pre><code>type MessageTypingIndicator = {\n  /** If true, you should countdown from 20 and then treat it like recipient stopped typing */\n  isTyping: boolean\n  /** Session ID of conversation where typing indicator appeared or disappeared */\n  conversation: string\n}\n\nsession.on('messageTypingIndicator', (typingIndicator: MessageTypingIndicator) =&gt; {\n  console.log(\n    'Typing indicator', typingIndicator.isTyping ? 'appeared' : 'disappeared',\n    'in conversation', typingIndicator.conversation\n  )\n})\n</code></pre>"},{"location":"events/#screenshottaken","title":"<code>screenshotTaken</code>","text":"<p>This event will be triggered on the instance that used notifyScreenshotTaken</p> <p>\"Screenshot taken\" message was sent in conversation.</p> <pre><code>type ScreenshotTakenNotification = {\n  /** Timestamp when screenshot was taken */\n  timestamp: number\n  /** Session ID of conversation where notification appeared */\n  conversation: string\n}\n\nsession.on('screenshotTaken', (notification: ScreenshotTakenNotification) =&gt; {\n  console.log(\n    '\"Screenshot taken\" notification appeared at', notification.timestamp, \n    'in conversation', notification.conversation\n  )\n})\n</code></pre>"},{"location":"events/#mediasaved","title":"<code>mediaSaved</code>","text":"<p>This event will be triggered on the instance that used notifyMediaSaved</p> <p>\"Attachment downloaded\" message was sent in conversation.</p> <pre><code>type MediaSavedNotification = {\n  /** Message's timestamp which has attachment that was downloaded */\n  timestamp: number,\n  /** Session ID of conversation where notification appeared */\n  conversation: string\n}\n\nsession.on('mediaSaved', (notification: MediaSavedNotification) =&gt; {\n  console.log(\n    '\"Attachment downloaded\" notification appeared about',\n    'downloading attachment in message with timestamp', \n    notification.timestamp, \n    'in conversation', notification.conversation\n  )\n})\n</code></pre>"},{"location":"events/#messagerequestapproved","title":"<code>messageRequestApproved</code>","text":"<p>\"Conversation request accepted\" message was sent in conversation.</p> <pre><code>type Profile = {\n  /** Name, displayed instead of your Session ID. Acts like nickname. All unicode characters are accepted except for `\uffd2` (0xffd2) which is reserved by Session for mentions. Max length: 64 characters */\n  displayName: string\n  /** Image, displayed near display name in Session clients. Acts like profile picture. */\n  avatar?: {\n    /** URL to avatar, uploaded to Session file server */\n    url: string\n    /** 32 bytes key used for avatar encryption */\n    key: Uint8Array\n  }\n}\ntype MessageRequestResponse = {\n  profile: Profile,\n  conversation: string\n}\n\nsession.on('messageRequestApproved', (message: MessageRequestResponse) =&gt; {\n  console.log(\n    'Your conversation request was accepted by',\n    message.conversation,\n    message.profile.displayName\n  )\n})\n</code></pre>"},{"location":"events/#call","title":"<code>call</code>","text":"<p>Call message was sent in conversation. Calls are not supported by Session.js yet.</p> <pre><code>type Call = {\n  uuid: string\n  type: SignalService.CallMessage.Type\n  from: string\n}\n\nsession.on('call', (call: Call) =&gt; {\n  console.log(\n    'You have received call-related message',\n    call.from,\n    call.type\n  )\n})\n</code></pre>"},{"location":"events/#reactionadded","title":"<code>reactionAdded</code>","text":"<p>This event will be triggered on the instance that used addReaction</p> <p>Reaction was added on a message.</p> <pre><code>type ReactionMessage = {\n  messageTimestamp: number\n  messageAuthor: string\n  reactionFrom: string\n  /** Emoji as string. Any unicode character(s) may be in this field, length is practically unlimited, validation is not performed by the @session.js/client library. You should probably only display the reaction, if it's a single valid emoji */\n  emoji: string\n}\n\nsession.on('reactionAdded', (reaction: ReactionMessage) =&gt; {\n  console.log(\n    'New reaction added on message with timestamp',\n    reaction.messageTimestamp,\n    'sent by', reaction.messageAuthor,\n    '\u2014', reaction.reactionFrom,\n    'reacted with', reaction.emoji\n  )\n})\n</code></pre>"},{"location":"events/#reactionremoved","title":"<code>reactionRemoved</code>","text":"<p>This event will be triggered on the instance that used removeReaction</p> <p>Reaction was added on a message.</p> <pre><code>type ReactionMessage = {\n  messageTimestamp: number\n  messageAuthor: string\n  reactionFrom: string\n  /** Emoji as string. Any unicode character(s) may be in this field, length is practically unlimited, validation is not performed by the @session.js/client library. You should probably only display the reaction, if it's a single valid emoji */\n  emoji: string\n}\n\nsession.on('reactionRemoved', (reaction: ReactionMessage) =&gt; {\n  console.log(\n    'Reaction removed from message with timestamp',\n    reaction.messageTimestamp,\n    'sent by', reaction.messageAuthor,\n    '\u2014', reaction.reactionFrom,\n    'reaction was', reaction.emoji\n  )\n})\n</code></pre>"},{"location":"getting-started/","title":"Getting started","text":"<p>Friendly reminder: this package can't be used and won't work with Node.js.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>By using this software, you are agreeing to abide by Terms of use. Shortly: no abuse and spam, you're solely responsible for your actions with this software.</p> <ol> <li>First install bun: https://bun.sh/</li> <li>Create a new Bun project in any directory, using <code>bun init</code> or manually</li> <li>Install session.js: <code>bun add @session.js/client</code></li> </ol> <p>Always make sure to await for initialization of library:</p> <pre><code>import { ready } from '@session.js/client'\nawait ready\n\n// ...\n</code></pre> <p>Otherwise you might get errors like <code>sodium.crypto_sign_seed_keypair is not a function</code></p>"},{"location":"getting-started/#quick-start","title":"Quick start","text":""},{"location":"getting-started/#sending-messages","title":"Sending messages","text":"<pre><code>import { Session, ready } from '@session.js/client'\nawait ready\n\nconst mnemonic = 'love love love love love love love love love love love love love'\nconst recipient = '054830367d369d94605247999a375dbd0a0f65fdec5de1535612bcb6d4de452c69'\n\nconst session = new Session()\nsession.setMnemonic(mnemonic, 'My username')\nconst response = await session.sendMessage({ \n  to: recipient, \n  text: 'Hello world' \n})\n\nconsole.log('Sent message with id', response.messageHash)\n</code></pre> <p>How to use instance with random mnemonic?</p>"},{"location":"getting-started/#sending-images-or-files","title":"Sending images or files","text":"<p>Attach image from URL to your message:</p> <pre><code>const imageData = await fetch('https://picsum.photos/100/100').then(res =&gt; res.arrayBuffer())\n\nconst file = new File([imageData], 'image.jpg', { type: 'image/jpeg' })\nawait session.sendMessage({ \n  to: recipient,\n  text: 'Image downloaded by URL:',\n  attachments: [file]\n})\n</code></pre> <p>Attach file from your file system to your message:</p> <pre><code>import path from 'path'\n// &lt;...&gt;\nconst filename = '/Users/kitty/Desktop/image.jpg'\nconst buffer = await fs.readFile(filename)\n\nconst file = new File([buffer], path.basename(filename), { type: 'image/jpeg' })\nawait session.sendMessage({\n  to: recipient, \n  text: 'Image from file:', \n  attachments: [file] \n})\n</code></pre>"},{"location":"getting-started/#polling-messages","title":"Polling messages","text":"<p>Check polling page for more info and examples on polling.</p> <pre><code>import { Session, Poller, ready } from '@session.js/client'\nimport { SnodeNamespaces, type Message } from '@session.js/types'\nawait ready\n\nconst mnemonic = 'love love love love love love love love love love love love love'\n\nconst session = new Session()\nsession.setMnemonic(mnemonic, 'Display name')\n\nconst poller = new Poller() // polls every 3 seconds\nsession.addPoller(poller)\n\nsession.on('message', (msg: Message) =&gt; {\n  console.log('Received new message!', \n    'From:', msg.from,\n    'Is from closed group:', msg.type === 'group',\n    'Group id:', msg.type === 'group' ? msg.groupId : 'Not group',\n    'Text:', msg.text ?? 'No text',\n  )\n\n  // If you want to access more properties and experiment with them, use getEnvelope and getContent\n  msg.getContent() // =&gt; SignalService.Content &lt;- useful message payload\n  msg.getCnvelope() // =&gt; EnvelopePlus &lt;- message metadata\n\n  // If you want to download attachments, use:\n  msg.attachments.forEach(async attachment =&gt; console.log(await session.getFile(attachment)))\n})\n</code></pre>"},{"location":"getting-started/#examples","title":"Examples","text":"<p>You can find fully complete examples in examples repository</p> <ul> <li>Simple example</li> <li>Browser</li> </ul>"},{"location":"mnemonic/","title":"Mnemonic encoding &amp; decoding","text":"<p>Use @session.js/mnemonic for operations related to mnemonic.</p> <pre><code>bun add @session.js/mnemonic\n</code></pre> <pre><code>import { encode, decode } from '@session.js/mnemonic'\n\nconst seed = decode('love love love love love love love love love love love love')\nconsole.log('Account seed', seed)\nconst mnemonic = encode(seed)\nconsole.log('Encoded mnemonic', mnemonic) // =&gt; love love love love love love love love love love love love\n</code></pre>"},{"location":"mnemonic/#generate-random-mnemonic","title":"Generate random mnemonic","text":"<p>To create a new Session instance with random mnemonic, you have to use two packages: @session.js/mnemonic and @session.js/keypair</p> <pre><code>bun add @session.js/mnemonic @session.js/keypair\n</code></pre> <p>Now generate random seed and encode it to get random mnemonic</p> <pre><code>import { generateSeedHex } from '@session.js/keypair'\nimport { encode } from '@session.js/mnemonic'\nimport { Session, ready } from '@session.js/client'\nawait ready\n\nconst mnemonic = encode(generateSeedHex())\nconsole.log('Mnemonic', mnemonic)\n\nconst session = new Session()\nsession.setMnemonic(mnemonic)\n</code></pre>"},{"location":"mnemonic/#add-your-own-mnemonic-language","title":"Add your own mnemonic language","text":"<p>You generally really shouldn't do that, because you have to find a secure compatible words dictionary first that will work with the system. This is how you add language to mnemonic encoder/decoder:</p> <pre><code>import { decode, mnemonicLanguages, addMnemonicLanguage } from '@session.js/mnemonic'\n\nmnemonicLanguages.russian = addMnemonicLanguage({\n  prefixLen: 3,\n  words: [/* ... */]\n})\ndecode('\u043b\u044e\u0431\u043e\u0432\u044c \u043b\u044e\u0431\u043e\u0432\u044c \u043b\u044e\u0431\u043e\u0432\u044c \u043b\u044e\u0431\u043e\u0432\u044c \u043b\u044e\u0431\u043e\u0432\u044c \u043b\u044e\u0431\u043e\u0432\u044c \u043b\u044e\u0431\u043e\u0432\u044c \u043b\u044e\u0431\u043e\u0432\u044c \u043b\u044e\u0431\u043e\u0432\u044c \u043b\u044e\u0431\u043e\u0432\u044c \u043b\u044e\u0431\u043e\u0432\u044c \u043b\u044e\u0431\u043e\u0432\u044c \u043b\u044e\u0431\u043e\u0432\u044c', 'russian')\n</code></pre>"},{"location":"ons/","title":"Oxen Name System (ONS)","text":"<p>ONS is a system of usernames that links you to registered Session ID mapping and allows you to buy mapping for a few other lokinet products. For more info on ONS, go to What is ONS?</p>"},{"location":"ons/#ons-resolving","title":"ONS resolving","text":"<p>Use @session.js/ons. This is a utility module that does not depend on any other packages published in @session scope.</p> <pre><code>bun add @session.js/ons\n</code></pre> <pre><code>import { resolve } from '@session.js/mnemonic'\n\nawait resolve('hloth') // =&gt; 057aeb66e45660c3bdfb7c62706f6440226af43ec13f3b6f899c1dd4db1b8fce5b\n</code></pre>"},{"location":"polling/","title":"Polling","text":"<p>Session.js allows you to poll messages on-demand and polling is opt-in, meaning you have to enable it in order to start receiving updates and new messages.</p>"},{"location":"polling/#quick-start","title":"Quick start","text":"<p>By default, if you don't provide <code>interval</code> in options to Poller class constructor, it will poll new messages each 2.5 seconds.</p> <pre><code>import { Session, Poller, ready } from '@session.js/client'\nimport { SnodeNamespaces, type Message } from '@session.js/types'\nawait ready\n\nconst mnemonic = 'love love love love love love love love love love love love love'\n\nconst session = new Session()\nsession.setMnemonic(mnemonic, 'Display name')\n\nconst poller = new Poller() // polls every 2.5 seconds\nsession.addPoller(poller)\n\nsession.on('message', (msg: Message) =&gt; {\n  console.log('Received new message!', \n    'From:', msg.from,\n    'Is from closed group:', msg.type === 'group',\n    'Group id:', msg.type === 'group' ? msg.groupId : 'Not group',\n    'Text:', msg.text ?? 'No text',\n  )\n\n  // If you want to access more properties and experiment with them, use getEnvelope and getContent\n  msg.getContent() // =&gt; SignalService.Content &lt;- useful message payload\n  msg.getCnvelope() // =&gt; EnvelopePlus &lt;- message metadata\n\n  // If you want to download attachments, use:\n  msg.attachments.forEach(async attachment =&gt; console.log(await session.getFile(attachment)))\n})\n</code></pre> <p>You can even attach multiple pollers to instance, for example, to configure interval of polling different namespaces:</p> <pre><code>// Poll DMs each 5 seconds\nconst dmMessagesPoller = new Poller({ interval: 5000, namespaces: new Set([SnodeNamespaces.UserMessages]) })\n// Poll user profile each 60 seconds\nconst profilePoller = new Poller({ interval: 60000, namespaces: new Set([SnodeNamespaces.UserProfile]) })\n\nsession.addPoller(dmMessagesPoller)\nsession.addPoller(profilePoller)\n\nsession.on('message', () =&gt; { /*...*/ })\nsession.on('syncDisplayName', (displayName) =&gt; {\n  console.log('Synced display name', displayName)\n})\n</code></pre> <p>You can use methods <code>startPolling</code>, <code>stopPolling</code> and <code>setInterval</code> on Poller instance to control it. Read more in JSDoc hints in your code editor or IDE.</p>"},{"location":"polling/#controlled-polling-on-demand","title":"Controlled polling on demand","text":"<p>To disable default interval of 2500 ms, pass <code>interval: null</code> to Poller constructor</p> <pre><code>const poller = new Poller({ interval: null })\nsession.addPoller(poller)\n\n// ... Some time later ...\n\nconst messages = await poller.poll()\nconsole.log('Received messages', messages)\n</code></pre>"},{"location":"profile/","title":"Profile customization","text":""},{"location":"profile/#display-name","title":"Display name","text":""},{"location":"profile/#avatar","title":"Avatar","text":""},{"location":"reactions/","title":"Reactions","text":"<p>TBD</p>"},{"location":"network/","title":"Network","text":"<p>You can pick existing network connector or write your own</p>"},{"location":"network/#overview","title":"Overview","text":"Network type   Supports onion routing   Description  Bun (local) \u274c  This network type is default and simpliest. It is intended to be used in the same process that @session.js/client instances run in. It's ideal if you just want to start and doing everything on server in one project without browser or other parts.  Bun (remote) for proxies \u274c  This network might be useful if you're building client in environment that does not allow you sending requests to Session nodes with self-signed certificates. This option is ideal for browser clients, because it handles all network connection on backend proxy that forwards client-side encrypted data to snodes. Check out simple browser example here."},{"location":"network/#creating-new-network-connector","title":"Creating new network connector","text":"<p>To implement your own network, write class that implements Network interface from <code>@session.js/types/network</code> with onRequest method. It must cover all RequestTypes from <code>@session.js/types/network/request</code>. Take a look at this example:</p> <pre><code>import type { Network } from '@session.js/types'\nimport { \n  RequestType, \n  type RequestGetSwarmsBody, \n  type RequestPollBody, \n  type RequestStoreBody, \n  type RequestUploadAttachment \n} from '@session.js/types/network/request'\n\nexport class MyNetwork implements Network {\n  onRequest(type: RequestType, body: object): Promise&lt;object&gt; {\n    switch(type) {\n      case RequestType.Store:\n        return // typeof ResponseStore\n\n      case RequestType.GetSnodes:\n        return // typeof ResponseGetSnodes\n\n      case RequestType.GetSwarms:\n        return // typeof ResponseGetSwarms\n\n      case RequestType.Poll:\n        return // typeof ResponsePoll\n\n      case RequestType.UploadAttachment:\n        return // typeof ResponseUploadAttachment\n\n      case RequestType.DownloadAttachment:\n        return // typeof ArrayBuffer\n\n      default:\n        throw new Error('Invalid request type')\n    }\n  }\n}\n</code></pre> <p>This is just an example in documentation, always develop against actual up-to-date RequestTypes enum in types package.</p>"},{"location":"network/bun-local/","title":"Bun local network","text":"<p>Default network that uses Bun's capabilities to fetch Session servers. It is intended to be used in the same process in the same environment as @session.js/client.</p> <p>If you're looking for network that works on proxy server (to host instance part on client side and do requests to Session servers via server side), use bun remote network. One such case is browser Session client, because browsers do not support connecting to Session servers.</p>"},{"location":"network/bun-local/#use-with-sessionjs","title":"Use with Session.js","text":"<p>Simply do not provide any network to <code>network</code> option in Session class constructor and this will be the default. You can optionally provide it as:</p> <pre><code>import { Session, ready } from '@session.js/client'\nimport { BunNetwork } from '@session.js/bun-network'\nawait ready\n\nnew Session({ network: new BunNetwork() })\n</code></pre>"},{"location":"network/bun-remote/","title":"Bun remote network","text":"<p>This module wraps bun local network but exports two files: for browser enviornment and server environment. Don't worry, modern bundlers such as webpack, rollup and bun should automatically pick up right parts of code for each environment.</p> <p>If you just want to run everything on one machine (both session instance and making requests to Session network), use bun local network</p>"},{"location":"network/bun-remote/#use-with-sessionjs","title":"Use with Session.js","text":"<p>Start by installing <code>@session.js/bun-network-remote</code> both on client-side and server-side. The package itself only does validation and connects client-side and server-side and all network management is bundled in another dependency <code>@session.js/bun-network</code> just like in local connector.</p> <p>Install it both in browser project and server proxy project:</p> <pre><code>bun add @session.js/bun-network-remote\n</code></pre>"},{"location":"network/bun-remote/#client-side-where-session-client-runs","title":"Client-side (where Session client runs)","text":"<pre><code>import { Session, ready } from '@session.js/client'\nimport { BunNetworkRemoteClient } from '@session.js/bun-network-remote'\nawait ready\n\nnew Session({ \n  network: new BunNetworkRemoteClient({ \n    proxy: 'https://my-proxy.example.org:12345/' \n    // this endpoint must be accessible in your environment\n    // i.e. if you're building Session client in browser, make sure\n    // that my-proxy.example.org has a valid SSL certificate, CORS and SSL settings\n  })\n})\n</code></pre> <p>Client-side part will send POST requests to this URL with JSON body.</p>"},{"location":"network/bun-remote/#server-side-proxy-server","title":"Server-side (proxy server)","text":"<pre><code>// Runtime must be Bun.sh\n// Web server can be anything: Express, Fastify, Elysia, Bun's web server, etc...\n// Validation is done internally and throws @session.js/error RuntimeValidation errors\n\nimport { Elysia } from 'elysia'\nimport { BunNetworkRemoteServer } from '@session.js/bun-network-remote'\nconst network = new BunNetworkRemoteServer()\n\nnew Elysia()\n  .post('/', ({ body }) =&gt; network.onRequest(body))\n  .listen(12345)\n</code></pre>"},{"location":"principles/files/","title":"Files in Session","text":"<p>This article explains how attachments and files work in Session messenger.</p>"},{"location":"principles/files/#how-to-send-an-attachment-with-message-in-session","title":"How to send an attachment with message in Session?","text":"<p>Session limits size of your attachments to 10 MB and uses special file server hosted by Oxen foundation that is used by all clients to upload and download encrypted files. Attachments always should have digest, key and size values that are checked by Session clients upon receiving and decrypting file. Files can have content-type, width, height, name, caption optional fields that Session clients will use to display information about file.</p> <p>@session.js/client will handle that encryption logic for you, wrapping it to just attaching File interface to sendMessage method's options and getFile method.</p>"},{"location":"principles/files/#what-happens-when-you-click-to-download-media-button-in-session","title":"What happens when you click to \"download media\" button in Session?","text":"<p>Though there is no practical and respectful to user's privacy way for Session file server to know when you download media from conversation, your Session client will send \"Media saved by you\" message in conversation letting your recipient know you've downloaded attachment from their message. This is done locally upon interaction with download button.</p> <p>@session.js/client allows you to download attachments without sending this message and, if you're building your own client, send these kind of messages to conversation with simple methods.</p>"},{"location":"principles/messages/","title":"Messages in Session","text":"<p>This article explains core principles behind Session's messages.</p>"},{"location":"principles/messages/#how-does-messaging-works-in-session-with-its-decentralization","title":"How does messaging works in Session with its decentralization?","text":"<p>Just like PGP emails back in the day, Session and similar messengers use end-to-end encryption. Session uses your private key (decoded from mnemonic) to encrypt data of your message to base64 string which is sent to swarms. That way, swarms hosted by other people in network never receive your private key.</p> <p>Swarm is a storage server for messages that is specifically designed to store encrypted messages. They are tied to pools of Session IDs, so your inbox might be on one swarm, while your recipient might be on another swarm. There are obviously many swarms available for a specific Session ID, you should choose random one to provide security. Swarms sync messages between each other, so you shouldn't store your message to all of them, just pick one of available. So before sending a message you must find a swarm that serves the specified Session ID.</p> <p>To find swarm that serves for a specific Session ID, you should use a dedicated method <code>get_swarm</code> in request to Session Service Node, which returns list of available swarms. But even before that, you should get a list of service nodes that work right now and can return you a list of available swarms for specified Session ID. To get list of service nodes in Session network, you must pick one of Seed Nodes which is official Oxen foundation servers that serve as directory list of servers in decentralized network. </p> <p>There are three seed nodes hosted by Oxen foundation (developers of Session): - seed1.getsession.org - seed2.getsession.org - seed3.getsession.org</p> <p>You can pick any of them to request service nodes list and preferrably add mechanism that switches from seed1 to seed2 etc when one is unavailable.</p> <p>All requests to swarms, service nodes, and seed nodes are made using JSON RPC format. All of them have their own self-signed certificate. For seed nodes, you should implement \"certificate pinning\", i.e. hardcode seeds servers certificates data directly in your code for maximum security. For service nodes and swarms, you will receive their certificates data in list requests.</p> <p>@session.js/client handles all that logic for you. You can simply pass Session ID and message and it will send the message for you. Additionally, there is getSwarm method that does everything described above but returns swarm's ip address and port for your custom logic.</p>"},{"location":"principles/messages/#how-does-storing-messages-on-swarms-work","title":"How does storing messages on Swarms work?","text":"<p>As said previously, you have to find swarm for specific Session ID. Do not mistake it with your own swarm: when you want to send message to recipient, you should find and use recipient's swarm. Since Session is built on top of Signal protocol, it uses Signal's protobuf schema and Signal's messages classes to serialize message data and encrypt it locally using private key. Then it uses <code>store</code> method to save message in swarm storage.</p> <p>@session.js/client allows you to create any number of instances in single JavaScript file that can send as many messages as you want with a simple yet flexible API.</p>"},{"location":"principles/messages/#how-does-messages-polling-work","title":"How does messages polling work?","text":"<p>Similar to messages storing, to poll messages Session client would first find working service node using seed nodes, then ask for swarm for that specific Session ID (pubkey) and make frequent JSON RPC requests with <code>retrieve</code> method to get messages. To keep track of new messages, you'll typically use last hashes parameter. While messages in Session do have a unique identifier that is unique across all clients \u2014 hash, it looks like it either had been added too late or borrowed from Signal, because many interactions that refer to specific message (such as reply to previously sent message, messages deletion etc) use timestamp instead of hash. You'll mostly use messages hashes only for polling-related logic.</p> <p>@session.js/client wraps polling into a simple interface, at the same time allowing you to customize polling as you want with all encryption and low-level logic encapsulated and processed by the library.</p>"},{"location":"principles/messages/#how-do-you-delete-messages-in-session","title":"How do you delete messages in Session?","text":"<p>Since Session clients mostly strive to keep everything local, Session has come up with a smart decision to create \"unsend\" messages which are control messages that instruct Session clients to remove specific message from local database and stop showing it to that client's user. Session clients usually also send request with <code>delete</code> method to swarms to delete the message in their storage, in case recipient hasn't polled the message yet.</p>"},{"location":"principles/messages/#how-long-do-messages-are-stored-in-session","title":"How long do messages are stored in Session?","text":"<p>Swarms usually keep messages for 14 days, but some messages can be sent with expiring config.</p>"},{"location":"principles/messages/#control-messages","title":"Control messages","text":"<p>All events in Session are called Messages, specifically they are sent in VisibleMessage class which, when deserialized, has one of these properties: - DataMessage \u2014 chat bubble message. Reaction added/removed events are also sent as DataMessage, with reaction property and empty string body. - DataMessage with syncTarget set (sent to your own swarm) \u2014 used by Session clients to sync between logged devices, basically tells that we have sent message to someone specified in syncTarget field - UnsendMessage \u2014 delete message - SharedConfigMessage \u2014 syncs profile including display name and avatar with all clients. Earlier, Session clients used ConfigurationMessage but now they'll display that one of your devices runs legacy outdated version if they receive ConfigurationMessage. Parameters are generated using libsession-util library written in c/c++ - ReadReceiptMessage \u2014 recipient seen your message - TypingIndicatorMessage \u2014 recipient has started or stopped typing - ConversationRequestMessage \u2014 response to yours (or someone else's) conversation request - DataExtractionMessage \u2014 recipient saved attachment in your conversation or took screenshot</p>"},{"location":"principles/users/","title":"Users in Session","text":"<p>This article explains core principles behind Session's accounts.</p>"},{"location":"principles/users/#how-accounts-in-session-messenger-work","title":"How accounts in Session messenger work?","text":"<p>In Session, there are no \"accounts\" in terms of persistant entities. Instead, there are inboxes where you receive your messages and can assosiate display name, avatar and ONS (link to Session ID) with. Technically, no one including you own your inbox. You can manage your inbox when you have access to it, and you have access when you have mnemonic (which is essentially a private key that is used to decrypt messages in that inbox).</p>"},{"location":"principles/users/#what-is-session-id","title":"What is Session ID?","text":"<p>Session ID is your inbox address which is x25519 32 bytes public key aka Curve25519. It is always prepended with <code>05</code>, which makes it 66 characters long (32 bytes -&gt; 64 characters + <code>05</code> prefix).</p> <p>Using @session.js/mnemonic and @session.js/keypair you can quickly generate random seeds, convert them to keypairs used by Session, get x25519 public key from it and encode to mnemonic that can be used in Session client.</p> <pre><code>import { generateSeedHex, getKeypairFromSeed } from '@session.js/keypair'\nimport { encode } from '@session.js/mnemonic'\n\nconst seedHex = generateSeedHex() // generate random 16 bytes seed that should be kept secure\nconst keypair = getKeypairFromSeed(seedHex) // derive public and private x25519 and ed25519 keys\nconst sessionID = keypair.x25519.publicKey // Session ID is x25519 public key\nconst mnemonic = encode(seedHex) // mnemonic is 13 words for accessing your Session\n</code></pre>"},{"location":"principles/users/#how-to-register-in-session","title":"How to register in Session?","text":"<p>Since there are no accounts, you can't register. Instead, your device generates a random private key (which can be displayed as encoded mnemonic), which is then converted to public key (which can be displayed as hex which is your Session ID). Public key allow another person to encrypt message, private key allows you to decrypt message. Obviously, you share public key (Session ID) so that other people can write you messages and never share private key (so that no one can read your messages except you).</p> <p>@session.js/client handles all encryption logic for you.</p>"},{"location":"principles/users/#how-to-delete-account-in-session","title":"How to delete account in Session?","text":"<p>Since there are no accounts, you can't delete it. Moreover, as stated above, you can't even own it. You just hope that theoretically no one will ever guess your private key (or mnemonic) to read your messages and write messages from your inbox.</p> <p>However, you can delete all data that is assosiated with your inbox. Read how messages work in Session</p>"},{"location":"principles/users/#what-is-ons","title":"What is ONS?","text":"<p>As said above, a person must have your public key (Session ID) to send you a message. Session IDs are hard to remember, as they're always 66 characters long and consist only of hex characters (a-f, 0-9). There is Session Vanity ID generator which can get you somewhere about first 5 desired characters, but the rest 61 characters are still random. As you might have guessed, this generator just iterates over random private keys and derives public keys (Session ID) until a match is found, and, if we were able to generate all 66 characters, that would mean we can compromise any known Session ID's private key.</p> <p>Usernames are a popular way to access each other's chats without remembering whole address. They are unique and simply act as a link to full address. Session has its own usernames system called Oxen Name System (ONS) which allows you to buy a mapping to your Session ID (plus a few other integrated lokinet projects) for 7 OXEN which at time of writing this article is about 1$. Payments are processed inside of Oxen blockchain, which makes it secure. ONS deserves whole another article, so for now just keep in mind that you can buy username in Session which simply acts like a link to your Session ID.</p> <p>@session.js/ons handles resolving ONS-&gt;Session ID encryption logic for you, so you just have to provide ONS and you'll receive Session ID. Alternatively, there is https://ons.sessionbots.directory/ which is a registry of ONS names with local client-side quick search among all registered ONS names in Session network.</p>"},{"location":"principles/users/#how-session-profiles-work","title":"How Session profiles work?","text":"<p>As previously discussed, there are no accounts in Session, so you can't get profile by account ID like in Telegram or any other centralized messenger or social media. Moreover, for privacy, Session clients shouldn't show profile display name and avatar unless user accepts conversation request or explicitly agrees to share profile with recipient. Instead of fetching it everytime, profiles in Session are saved locally in database for contacts.</p> <p>Profile data comes with each visible chat message and with conversation request accepted message. So each time Session client sends a message to another user or accepts a request to talk, this message also contains your display name and avatar \u2014 that's how they're updated in local databases of other clients.</p> <p>To be clear: there is no way to get avatar or display name of specific Session ID unless they send that data inside of encrypted chat message bubble. Until Session client received display name and avatar in either of these messages, it should display just Session ID.</p>"},{"location":"storage/","title":"Storage","text":"<p>You can use any existing storage adapter or write your own</p>"},{"location":"storage/#overview","title":"Overview","text":"Storage type   Description  In-memory Default storage that stores data in memory, that is reset after this process exits or tab is closed. Ideal for short living one-time bots or testing. It is not persistant. Persistant file-based key=value storage with `fs` Simple storage that stores everything in memory and periodically syncs it with locally stored file in key=value format. `filePath` is optional and defaults to `./storage.db`"},{"location":"storage/#creating-new-storage-adapter","title":"Creating new storage adapter","text":"<p>To implement your own storage, write class that implements Storage interface from <code>@session.js/types/storage</code>. Take a look at this example with in-memory storage</p> <pre><code>import type { Storage } from '@session.js/types'\n\nexport class MyInMemoryStorage implements Storage {\n  storage: Map&lt;string, string&gt; = new Map()\n\n  get(key: string) {\n    return this.storage.get(key) ?? null\n  }\n\n  set(key: string, value: string) {\n    this.storage.set(key, value)\n  }\n\n  delete(key: string) {\n    this.storage.delete(key)\n  }\n\n  has(key: string) {\n    return this.storage.has(key)\n  }\n}\n</code></pre>"},{"location":"storage/file-keyval/","title":"Persistant file-based key=value storage with fs","text":"<p>Simple persistant storage that stores everything in memory and periodically syncs it with locally stored file in key=value format.</p>"},{"location":"storage/file-keyval/#install","title":"Install","text":"<pre><code>bun add @session.js/file-keyval-storage\n</code></pre>"},{"location":"storage/file-keyval/#use-with-sessionjs","title":"Use with Session.js","text":"<p><code>filePath</code> is optional and defaults to ./storage.db</p> <pre><code>import { Session } from '@session.js/client'\nimport { FileKeyvalStorage } from '@session.js/file-keyval-storage'\n\nnew Session({ \n  storage: new FileKeyvalStorage({ \n    filePath: 'some-file-path.db' \n  })\n})\n</code></pre>"},{"location":"storage/in-memory/","title":"In-memory storage","text":"<p>Default storage. It's not persistant, so it's ideal for one-time instances.</p>"},{"location":"storage/in-memory/#use-with-sessionjs","title":"Use with Session.js","text":"<p>You don't need to provide it to Session instance constructor, because it is used by default. You can optionally provide it as:</p> <pre><code>import { Session } from '@session.js/client'\nimport { InMemoryStorage } from '@session.js/client/storage'\n\nnew Session({ storage: new InMemoryStorage() })\n</code></pre>"}]}